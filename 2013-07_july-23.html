<!doctype html>
<meta charset="utf-8">
<title>July 23 Meeting Notes</title>
<h1>July 23 Meeting Notes</h1>
<p>John Neumann (JN), Luke Hoban (LH), Rick Hudson (RH), Allen Wirfs-Brock (AWB), Yehuda Katz (YK), Anne van Kesteren (AVK), Jeff Morrrison (JM), Sebastian Markage (SM), Paul Leathers (PL), Avik Chaudhuri (AC), Ian Halliday (IH), Alex Russell (AR), Dave Herman (DH), Istvan Sebestyen (IS), Mark Miller (MM), Norbert Lindenberg (NL), Erik Arvidsson (EA), Waldemar Horwat (WH), Eric Ferraiuolo (EF), Matt Sweeney (MS), Doug Crockford (DC), Rick Waldron (RW)</p>
<p>JN: Brendan will be here tomorrow</p>
<p>Introductions.</p>
<h2>Agenda</h2>
<p>(<a href="https://github.com/tc39/agendas/blob/master/2013/07.md">https://github.com/tc39/agendas/blob/master/2013/07.md</a>)</p>
<p>Discussion about getting agenda items in earlier, general agreement.</p>
<p>AWB: Clarifying #5 Open Issues (previously presented as a slide deck, now easier to track)</p>
<h4>Consensus/Resolution</h4>
<p>Will continue to use Github as the agenda tool, with the constraints:</p>
<ul>
<li>Agenda should be &quot;locked in&quot; 1 week prior to meeting</li>
<li>Agenda URL will be posted to es-discuss immediately following the current meeting</li>
<li>Allen has running &quot;Open Items&quot; section.</li>
</ul>
<p>Corrections:</p>
<ul>
<li>What to expect in the RFTG mode</li>
<li>Add JSON document to #9 JSON</li>
</ul>
<p>Agenda Approved.</p>
<p>JN: Welcomes new Facebook participants</p>
<h2>4.1 ES6 Status Report</h2>
<p>(Allen Wirfs-Brock)</p>
<p>AWB: Draft published, Revision 16</p>
<ul>
<li>Backed out the Symbols as non-wrapper types from Revision 15</li>
<li>Section items renumbered for clarity</li>
<li>Want to re-org/re-order the entire document
<ul>
<li>Primarily re-order the lexical grammar and syntax (currently out of order by 3 sections)</li>
</ul></li>
</ul>
<p>LH: (asked for motivation)</p>
<p>WH: Noticed...</p>
<ul>
<li>Changed for-in to disallow left side assignment expression.</li>
<li>Syntax for arrow doesn't propagate the NoIn-ness of grammar rule. A NoIn arrow grammar production expands into a seqence that ends with a non-NoIn expression.
If we hadn't changed for-in to disallow left side initializers, this would break the grammar by allowing in's to leak into a NoIn expression.
However, we have changed for-in to disallow left side initializers. Given that, the regular/NoIn syntax rule bifurcation is now pointless. We have an opportunity to simplify and regularize the grammar here.</li>
</ul>
<p>AWB: Will look into removing the NoIn productions.</p>
<p>LH: This was discussed recently on es-discuss
(need reference)</p>
<p>AWB:</p>
<ul>
<li>Further rationalization of alphabetizing Chapter 15</li>
<li>Reminder that people should use the bug tracker for spec revision issues.</li>
<li>Implementor feedback will be prioritized</li>
</ul>
<p>LH: Re: initializer argument with an &quot;entries&quot; property will be used to create the entries in the Map (7.a)</p>
<p>&quot;Let hasValues be the result of HasProperty(iterable, &quot;entries&quot;).&quot;</p>
<p>AWB: Explains the rationale of creating a new map from an existing map</p>
<pre><code class="language-js">var m1 = new Map();
var m2 = new Map(m1);
</code></pre>
<p>LH/DH/YK/RW: Should be:</p>
<pre><code class="language-js">var m1 = new Map();
var m2 = new Map(m1.entries());
</code></pre>
<p>EA: Should just use <code>@@iterator</code>, which is <code>entries</code>, but without explicitly checking for a property called <code>entries</code>.</p>
<p>DH: Advocate for uniform API, test for existance, assumes it's iterable, 2 element array-likes and initialize.</p>
<p>MM: Have we decided on the convention that an iterator of X is also an interable of X. A map.entries() gives you an iterator.</p>
<p>YK: map is already an iterable</p>
<p>DH: Should make sense to pass an iterator to Map</p>
<p>AWB: All the built in iterators are also iterables</p>
<p>DH: Agree, though this has been debated</p>
<p>WH: What happens...</p>
<pre><code class="language-js">new Map([ &quot;abc&quot;, &quot;defg&quot;, &quot;hi&quot; ]);
new Map([{ 1: 10, 0: 20 }]);
</code></pre>
<p>BE: The first one makes a map mapping &quot;a&quot; → &quot;b&quot;, &quot;d&quot; → &quot;e&quot;, &quot;h&quot; → &quot;i&quot;. The second one makes a map of 20 → 10.</p>
<p>AWB: The algorithm for Map should check for entries to be Object</p>
<p>DH:</p>
<p>MM: I don't think we should special case for string</p>
<p>AR: Agree, but not with example</p>
<p>MM: Making a special case for String seems like an odd decision</p>
<p>AR: In the case of i18n where we can't change the code point... you can imagine having a string map, but if I can just pass in a string.</p>
<p>... Don't object, just exploring</p>
<p>AWB: Objecting. What use case can you imagine where programmers intend for strngs to be array-like?</p>
<p>MM: None reasonable</p>
<p>...</p>
<p>MM: Question about value objects. If the value object responds to Get(0) or Get(1)</p>
<p>WH: with Mark, don't want special tests for different types</p>
<p>LH: If I do...</p>
<pre><code class="language-js">new Map([ 1, 2, 3 ]);
</code></pre>
<p>I will get <code>undefined, undefined, undefined</code>, which is a stronger case for making the check</p>
<p>DH: +1</p>
<p>WH: Elsewhere, we've gone to detect duplicate errors</p>
<p>AWB: Checking for duplicates will duplicate the cost</p>
<p>MM: The impl of any hash table will require a test for duplicate keys</p>
<p>AWB: What about key, values that have been collected over time?</p>
<p>MM: There are use cases for duplicate key checks</p>
<p>LH: Historically, we make duplicate checks when it's syntactic, and this is the first time we're trying to apply duplicate checks to runtime semantics</p>
<p>MM: If something you didn't expect happens once, i'd much prefer an error</p>
<p>YK/RW: That's bad for the web</p>
<p>RW: Map would become a &quot;try/catch&quot; case</p>
<p>... mixed discussion about the precedent for loud or quiet handling</p>
<p>WH: Are there any other constructor that throw when created &quot;incorrectly&quot;?</p>
<p>RW: In non-strict mode, a program can create an object with all duplicate keys and never fail in production</p>
<p>...</p>
<p>MM:</p>
<p>AC: Creation can be what is the least requirement for what it takes to create a map. Taking an arbitrary structure and make a map and it's perfectly good semantics to</p>
<p>LH/MM: Offline conversation about what qualifies for extra defense.</p>
<p>DH: Select cases where there is easy to argue that there few legitimate uses, ok to have occassion sanity tests. In general, JavaScript does not go out of it's way to provide you with defensive mechanisms. It's hard to predict where people are going to get hurt, better to allow them to decide.</p>
<p>WH: Paying for consequences where <code>with</code> doesn't protect against collisions.</p>
<p>AWB: Try to apply my model when writing these algorithms, please try to read the algorithms when they are published</p>
<h4><del>Consensus/Resolution</del></h4>
<ul>
<li><p>Map contructor, accepts optional initializer</p></li>
<li><p>If initializer undefined, creates an empty map</p></li>
<li><p>If initializer defined, invoke the @@iterator to create the entries from.</p>
<ul>
<li>For each entry, check if non-null object, throw if not (If Type(map) is not Object then, throw a TypeError exception.)</li>
<li>pull off the 0 and 1 property</li>
<li>make 0 a key and 1 value</li>
<li>No check for duplicate keys</li>
</ul></li>
<li><p>Remove the explicit check for an &quot;entries&quot; property, this is implied by the
check for &quot;@@iterator&quot;</p></li>
</ul>
<p><strong>UNRESOLVED</strong></p>
<p>AWB: Will put a note in the spec: &quot;Unresolved: how to handle duplicate keys&quot;</p>
<p>WH: Don't yet have consensus on how to handle duplicates, would like to discuss computed properties</p>
<h2>4.3 Array.prototype.values</h2>
<p>(Allen Wirfs-Brock, Rick Waldron)</p>
<p>AWB: Ext.js uses a <code>with(...) {}</code></p>
<pre><code class="language-js">function f(values) {
  with(values) {
    ...
  }
}

f([]);
</code></pre>
<p>YK: Means that we can't add common names for common objects?</p>
<p>RW: ...Explained that Ext.js fixed the issues, but face a commercial customer update challenge. In the meantime, it continues to break several large scale sites.</p>
<p>AWB: Brendan's workaround (from post on the list)</p>
<pre><code class="language-js">values() -&gt; @@values();
keys() -&gt; @@keys();
entries() -&gt; @@entries();
</code></pre>
<p>Importing from a module...</p>
<pre><code class="language-js">values() -&gt; values([]);
keys() -&gt; keys([]);
entries() -&gt; entries([]);
</code></pre>
<p>DH: Warming up to the idea of a general purpose protocol, implement your map-like protocol.</p>
<p>WH: But now you need an <code>import</code></p>
<p>EA/AR/DH: Web breaking... but why not break</p>
<p>AR: Meta property, [[withinvisible]]</p>
<p>(Way too much support for this)</p>
<p>DH: This idea is fantastic</p>
<p>EA: Very useful to the DOM, may not need another bit on the object, maybe just a &quot;whitelist&quot;.</p>
<p>MM: A very small list of names that &quot;with&quot; doesn't intercept</p>
<p>YK: Could, but semantically almost the same thing</p>
<p>EA: But without the extra bit on all objects</p>
<p>MM: Don't want to require a new bit for all objects.</p>
<p>DH: Need to fully explore the effects on the rest of the language..</p>
<ul>
<li>Blacklist for just Array or all objects?</li>
</ul>
<p>EA: A blacklist that exists, string names, when you enter <code>with(){}</code>, the blacklist must be checked.</p>
<p>MM: If the base object is Array, if the name is on the whitelist</p>
<p>EA: Have an instanceof check? This problem happens in the DOM with Node</p>
<p>EA/YK/AR: We can actually use this for several use cases.</p>
<p>EA: The issue needs instanceof to check the prototype chain.</p>
<p>AWB: For objects you want to treat this way.</p>
<p>DH: The middle ground...</p>
<p>@@withinvisible, well known symbol</p>
<pre><code class="language-js">Array.prototype[ @@withinvisible ] = [
  &quot;values&quot;,
  &quot;keys&quot;,
  &quot;entries&quot;
];
</code></pre>
<p>AVK: Might have a more generic name, can be used with event handlers</p>
<p>DH: <code>@@unscopable</code>?</p>
<pre><code class="language-js">Array.prototype[ @@unscopeable ] = [
  &quot;values&quot;,
  &quot;keys&quot;,
  &quot;entries&quot;
];
</code></pre>
<p>WH/MM/RW/YK: <strong>actual clapping</strong></p>
<p>... Mixed discussion about performance. General agreement that penalties for using <code>with</code> is ok.</p>
<p>AWB: Code may override this, but at their own risk. For example</p>
<h4>Consensus/Resolution</h4>
<ul>
<li>@@unscopeable</li>
<li>A blacklist, array of strings names that will not resolve to that object
within <code>with() {}</code></li>
</ul>
<p>DH: This is about the extensible web ;)</p>
<h2>3 Approval of the minutes from May 2013 (2013/029)</h2>
<p>JN: Need to approve the notes...</p>
<p>Are there are any changes to approve?</p>
<p>(none)</p>
<h4>Consensus/Resolution</h4>
<ul>
<li>Approved.</li>
</ul>
<h2>9 JSON</h2>
<p>(Doug Crockford)</p>
<p>DC: Gives background re: JSON WG and presents a proposed JSON standard to be submitted to Ecma.</p>
<ul>
<li>Please read tonight for review tomorrow</li>
</ul>
<p>NL: Benefit from reading the JSON mailing list threads.</p>
<p>YK: Will be painful.</p>
<p>AR: This document seems completely unobjectional</p>
<p>DC: IETF claims abstract formats cannot work</p>
<p>Mixed discussion about consequences.</p>
<p>(Read and be prepared for meeting tomorrow)</p>
<h2>4.2 Add fill and copySlice methods to Array.prototype and Typed Arrays</h2>
<p>(Allen Wirfs-Brock)</p>
<p><a href="http://wiki.ecmascript.org/doku.php?id=strawman:array_fill_and_move">http://wiki.ecmascript.org/doku.php?id=strawman:array_fill_and_move</a></p>
<p>AWB: The Chronos group want to add methods</p>
<ul>
<li>fill a span of a typed array</li>
<li>move copy, with care for the overlap</li>
</ul>
<h3>Array.prototype.fill (Informal Spec)</h3>
<pre><code class="language-js">Array.prototype.fill = function fill(value, start=0, end=this.length) {
  /*
    Every element of array from start up to but not including end is assigned value.
    start and end are coerced to Number and truncated to integer values.
    Negative start and end values are converted to positive indices relative to the length of the array:

       if (start &lt; 0) start = this.length-start

    Reference to start and count below assume that conversion has already been applied

    If end &lt;= start no elements are modified.
    If end &gt; this.length and this.length is read-only a Range error is thrown and no elements are modified.
    If end &gt; this.length and this.length is not read-only, this.length is set to end
    Array elements are set sequentially starting with the start index.
    If an element is encountered that cannot be assigned, a TypeError is thrown.
    Element values are assigned using [[Set]]

    The array is returned as the value of this method
  */
}
</code></pre>
<p>Examples</p>
<pre><code class="language-js">aFloatArray.fill(Infinity);  // Fill all elements with Infinity
aFloatArray.fill(-1, 6);     // Fill all elements starting at index 6 with -1
aFloatArray(1.5, 0, 5);      // Fill the first five elements with 1.5
aUint8Array(0xff, -2);       // Place 0xff in the last two elements
[ ].fill(&quot;abc&quot;, 0, 12)
    .fill(&quot;xyz&quot;, 12, 24);     // Create a regular array, fill its first dozen
                              // elements with &quot;abc&quot;, and its 2nd dozen elements
</code></pre>
<h3>Array.prototype.copySlice (Informal Spec)</h3>
<pre><code class="language-js">Array.prototype.copySlice = function copySlice(target = 0,start = 0, end = this.length ) {
/*
  The sequence of array elements from start index up to but not including end index are copied within
  the array to the span of elements starting at the target index.

    target, start, and end are coerced to Number and truncated to integer values.
    Negative indices are converted to positive indices relative to the length of the array.
    If end &lt;= start no elements are modified.
    If end &gt; this.length a Range error is thrown and no elements are modified.
    If target + (end-start) &gt; this.length and this.length is read-only a Range error is thrown and no elements are modified.
    If target + (end-start) &gt; this.length and this.length is not read-only, this.length is set to target+(end-start).

   The transfers takes into account the possibility that the source and target ranges overlap. Array elements are
   sequentially transferred in a manner appropriate to avoid overlap conflicts. If target &lt;= start a left to right
   transfer is performed.  If target&gt;start a right to left transfer is performed.

   If a target element is encountered that cannot be assigned, a type error is thrown and no additional elements are modified.
   Sparse array &quot;holes&quot; are transferred just like for other array functions.

   The array is returned as the value of this method
*/
}
</code></pre>
<p>Examples</p>
<pre><code class="language-js">[ 0, 1, 2, 3, 4 ].copySlice(0, 2);
// [ 2, 3, 4, 3, 4 ]

[ 0, 1, 2, 3, 4 ].copySlice(2, 0, 2);
// [ 0, 1, 0, 1, 4 ]

[ 0, 1, 2 ].copySlice(1);
// [ 0, 0, 1, 2 ]

Int8Array.from([ 0, 1, 2 ]).copySlice(1);      // RangeError
Int8Array.from([ 0, 1, 2 ]).copySlice(1, 0, 2);  // Int8Array 0,0,1
Int8Array.from([ 0, 1, 2 ]).copySlice(0, 1, 2);  // Int8Array 1,2,2
</code></pre>
<p><strong>Moving data within an array, destructively on the calling array</strong></p>
<p>AWB: Possibly rename <code>copySlice</code> =&gt; <code>copyWithin</code></p>
<p>LH: Should Typed Arrays have the same surface as Array?</p>
<p>DH: Typed arrays better behaving and better performing since they guarantee density. (non-sparse)</p>
<ul>
<li>Notes concat as the only array method that expects explicit array-ness</li>
</ul>
<p>RW: Do we have consensus</p>
<p>DH: Brendan had issue with <code>fill</code></p>
<p>AWB: Brendan's issue was the similarity with <code>copySlice</code> and had suggested <code>fillSlice</code>.</p>
<p>DH: Not sure I understand his objection...</p>
<h4>Consensus/Resolution</h4>
<ul>
<li>Agreement in room</li>
<li>Would like Brendan's input</li>
</ul>
<h2>4.4 Consider deferring ES6 Refutable Matching.</h2>
<p>(Allen Wirfs-Brock)</p>
<p>AWB: In March, we agreed to add refutable pattern matching; began working on adding this to destructuring and realized the work involved would be too great, considering the time frame remaining for ES6.</p>
<p>Propose to defer refutable pattern matching.</p>
<p>(whiteboard)</p>
<p>The current spec would attempt to do a ToObject(10); and would throw:</p>
<pre><code class="language-js">let { a, b } = 10;
</code></pre>
<p>What happens when you reference a property that doesn't exist on the object, will throw:</p>
<pre><code class="language-js">let { a, b } = { a: 10, c: 20 };
</code></pre>
<p>To avoid throwing:</p>
<pre><code class="language-js">let { a, b = undefined } = { a: 10, c: 20 };
</code></pre>
<p>YK: Removing the question mark breaks the consensus.</p>
<p>AVK: Is it hard to spec the &quot;?&quot; on the outside? Allowing only one level?</p>
<p>AWB: It wouldn't be hard, but it creates a weird language issue.</p>
<p>YK/AWB: It's easy to do in the grammar</p>
<p>LH: What was in the spec, solved 80% of the cases, we moved to a solution for 100% and this will set us back to 20%, which isn't acceptable.</p>
<p>AWB: What happens at the parameter list level?</p>
<p>YK: Ah, there is no place to put the out &quot;?&quot;</p>
<p>DH: Agrees... as long as we have a fail-soft, we're ok (YK/LH/RW agree)</p>
<p>YK: We could make the extra sigil mean refutable.</p>
<p>WH:</p>
<pre><code class="language-js">let [a, b] = &quot;xyz&quot;;
</code></pre>
<p>YK: Why Andreas would have argued strongly against a refutable sigil?</p>
<p>DH: I think this will fail without inclusion of Brendan and Andreas</p>
<p>AWB: Andreas is fine with dropping refutable matching</p>
<p>DH: Are you sure?</p>
<p>Current spec is fail soft</p>
<p>As long as Brendan and Andreas are ok with it, we can fall back to fail soft.</p>
<p>AC: The fail soft is consistent with JS behaviour. If you want something stricter, then the problem should be on the right side, not the left side. Otherwise you need to introduce an operator for the left.</p>
<p>AWB: (reads back conversation from Andreas)</p>
<p>DH/YK: He doesn't seem to say anything about returning to fail soft.</p>
<p>LH: I think we've exhausted the conversation</p>
<p>WH: If we don't do it now, the behavior of refutable and regular rules will be inconsistent in the future; i.e., a trivial refutable rule that doesn't actually make use of the refutable features will behave inconsistently with a textually identical nonrefutable rule.</p>
<p>YK: But you'll be able to opt-in to the full set of &quot;refutables&quot;</p>
<p>WH: I think it's uglifying the future.</p>
<p>YK/LH: It is.</p>
<p>DH: There is precendence in Mozilla's destructuring, that doesnt have refutable matching.</p>
<p>LH: If we added the bang which is the strict mode for this and adds the bang in front, opts in.</p>
<p>AWB: The next part...</p>
<p>WH: The string example:</p>
<pre><code class="language-js">let [a, b] = &quot;xyz&quot;;
</code></pre>
<p>Should there be implicit ToObject on the right side?</p>
<p>YK: We agreed <code>new String()</code> solves the problem, if that's what you actually wanted to do.</p>
<h4>Consensus/Resolution</h4>
<ul>
<li>No implicit <code>ToObject()</code> on the right side (eg. the string will throw)</li>
</ul>
<h2>x.x Review of Proposed Features</h2>
<p>(Luke Hoban)</p>
<h3>Function toString</h3>
<p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:function_to_string">http://wiki.ecmascript.org/doku.php?id=harmony:function_to_string</a></p>
<p>MM: The one issue about Function toString, discovered since the strawman was written:</p>
<p>Since eval()uating a function declaration or function expression defaults to non-strict, a strict function must present the source code of its body as beginning with a “use strict” directive, even if the original function inherited its strictness from its context. This is the one case where the original local source code of the function is inadequate to satisfy this spec.</p>
<p>YK: Doesn't account for super, either</p>
<p>Discussion about identifiers captured from lexical environments.</p>
<p>Was the lexical environment strict?</p>
<h4>Consensus/Resolution</h4>
<p>Change wiki
strictness included in notion of lexical context. Thus</p>
<ul>
<li>always adequte for toString to preserve the original source</li>
<li>result behaviour equivalence does not require injecting &quot;use strict&quot;</li>
</ul>
<h3>Function name property</h3>
<p>(Allen Wirfs-Brock)
<a href="http://wiki.ecmascript.org/doku.php?id=harmony:function_name_property">http://wiki.ecmascript.org/doku.php?id=harmony:function_name_property</a></p>
<p>AWB: The spec doesn't have mechanisms for capturing the name based on the syntactic context.</p>
<p>LH:</p>
<pre><code class="language-js">let f = function() {}
</code></pre>
<p>...Needs to know &quot;f&quot;.</p>
<p>AWB: It's not an insignificant amount of work.</p>
<p>...Conversation Moves towards prioritization.</p>
<h3>Modules</h3>
<p>LH: Need to know that modules are going to be spec'ed asap.</p>
<p>DH: This is my next item to work on</p>
<p>AWB: Modules are the next most important and significant to address in the spec.</p>
<p><strong>High priority</strong></p>
<h3>Standard Modules</h3>
<p>DH: Back off on standard modules for ES6, very few things.</p>
<p>Standard Modules:</p>
<ul>
<li>Math</li>
<li>Reflect</li>
</ul>
<p>YK: All of the built-ins.</p>
<p>RW: If I want to avoid using a tainted built-in, <code>import { Array } from &quot;builtins&quot;;</code></p>
<p>DH: What does this directly solve?</p>
<p>YK/RW: When you want to get a fresh, untainted _____.</p>
<p>AWB: Who will write out the standard modules?</p>
<p>EF/YK/RW can work on this</p>
<p>Mixed discussion about feature dependency.</p>
<p>DH: Luke and I can craft a dependency graph offline.</p>
<h3>Binary Data</h3>
<p>On track (wiki near complete)</p>
<p><strong>High priority</strong></p>
<h3>Regexp Updates</h3>
<ul>
<li><a href="http://wiki.ecmascript.org/doku.php?id=harmony:regexp_y_flag">http://wiki.ecmascript.org/doku.php?id=harmony:regexp_y_flag</a></li>
<li><a href="http://wiki.ecmascript.org/doku.php?id=harmony:regexp_match_web_reality">http://wiki.ecmascript.org/doku.php?id=harmony:regexp_match_web_reality</a></li>
<li><a href="http://wiki.ecmascript.org/doku.php?id=harmony:regexp_look-behind_support">http://wiki.ecmascript.org/doku.php?id=harmony:regexp_look-behind_support</a></li>
<li><a href="http://wiki.ecmascript.org/doku.php?id=harmony:unicode_supplementary_characters">http://wiki.ecmascript.org/doku.php?id=harmony:unicode_supplementary_characters</a></li>
</ul>
<p><strong>Low priority</strong></p>
<p>DH: Optimistic that we can get Modules and Binary Data to green (in the spreadsheet)</p>
<h3>Proper Tail Calls</h3>
<p>DH: Just need to identify the tail position and finish the spec.</p>
<p>AWB: It's just a time consuming project. Property access in tail position? Not tail call.</p>
<p>DH: Safely:</p>
<ul>
<li>function call</li>
<li>method call</li>
</ul>
<h4>Consensus/Resolution</h4>
<ul>
<li>Plenty of work left.</li>
</ul>
<h2>4.7 Math</h2>
<p>(Dave Herman)</p>
<p>DH: Introduces need for 64bit float =&gt; 32bit float and projecting back into 64bit float. If we had a way to coerce into 32bit</p>
<ul>
<li>Can be simulated with TypedArray (put in a value, coerced, pull out)</li>
<li>To have a toFloat32</li>
</ul>
<p>EA: Does JSIDL Need this?</p>
<p>YK: Not that I know of</p>
<p>MM: The real number it designates is a number that is designatable as 64bit</p>
<p>DH: (confirms) If you have a coercion, the implementation could do a 32bit operation</p>
<p>WH: Note that for this to work, you must religiously coerce the result of every suboperation to float32. You can't combine operators such as adding three numbers together.</p>
<p>Given
x, y, z are all float32 values stored as regular ECMAScript doubles, the expressions</p>
<p>x+y+z
float32(x+y+z)
float32(float32(x+y)+z)</p>
<p>can all produce different results. Here's an example:</p>
<p>x = 1;
y = 1e-10;
z = -1;</p>
<p>Computing x+y+z using float32 arithmetic would result in 0. Computing float32(x+y+z) would not.</p>
<p>On the other hand, there is a very useful property that holds between float32 and float64 (but not between two numeric types in general such as float64 and float80), which is that, for the particular case of float32 and float64, DOUBLE ROUNDING is ok:</p>
<p>Given x, y are float32 values, the following identity holds, where +_32 is the ieee single-precision addition and +_64 is the ieee double-precision addition:</p>
<p>float32(x +_64 y) === x +_32 y</p>
<p>And similarly for -, *, /, and sqrt.</p>
<p>Note that this does not hold in general for arbitrary type pairs.</p>
<p>Here's an example of how DOUBLE ROUNDING can fail for other type pairs. Suppose that we're working in decimal (the issues are the same, I'm just using decimal for presentation reasons), and we compute a sum using arithmetic that has four decimal places and then round it to store it into a type that has two decimal places.</p>
<p>Let's say that the sum x+y is mathematically equal to 2.49495.
2.49495 (mathematically exact sum)</p>
<p>Then we get:
2.4950 (properly rounded result of invoking + on the wider 4-decimal place type)
2.50 (rounded again by coercion to narrower 2-decimal place type)</p>
<p>Yet, if we had invoked + on the narrower 2-decimal place type, we'd instead have gotten the result:
2.49 (mathematically exact sum rounded to narrower 2-decimal place type)</p>
<p>AWB: Is the proposal to expose a toFloat32?</p>
<p>DH: Yes and the Math object seems like the obvious place</p>
<p>RH: Also, toFloat16</p>
<p>DH: Long term, the solution will be value objects, but in the near term, this will have benefit much more quickly</p>
<p>WH: Found evidence that the optimizations are safe as long as the wider type is at least double the width of the narrower type plus two more bits: <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html</a> . This is the case for the float32/float64 pair (they're 24 and 53 bits wide respectively), but not in general.</p>
<h4>Consensus/Resolution</h4>
<ul>
<li>Math.toFloat32()</li>
</ul>
<p>More discussion about where (Math, Number.prototype)</p>
<h2>4.8 Stable Array.prototype.sort</h2>
<p>(Norbert Lindenberg)</p>
<p><a href="https://mail.mozilla.org/pipermail/es-discuss/2013-June/thread.html#31276">https://mail.mozilla.org/pipermail/es-discuss/2013-June/thread.html#31276</a></p>
<p>NL: Does anyone know of performance issues that prevent going to stable sort.</p>
<p>DH: Tread lightly, no one wants regression</p>
<p>EA: Libraries implement stable sort today because they need it.</p>
<p>YK: D3</p>
<p>MM: If the answer is that performance is negligible, then we should mandate stable sort. Otherwise, we don't. We need to answer the question first.</p>
<h4>Consensus/Resolution</h4>
<ul>
<li>Deferred</li>
</ul>
<h2>4.9 Time zones 1: Bugs or spec issues?</h2>
<p>(Norbert Lindenberg)</p>
<p><a href="https://mail.mozilla.org/pipermail/es-discuss/2013-July/032087.html">https://mail.mozilla.org/pipermail/es-discuss/2013-July/032087.html</a></p>
<p>Discussion around the semantics of Date</p>
<p>AVK/MM: Be able to create a date instance with a timezone, other then the current timezone</p>
<p>MM: ES5 implies a live communication channel into the Date instance</p>
<p>AWB: It's part of the algorithms</p>
<p>MM: We could say that we're going to stand on the ES5 spec.</p>
<h4>Consensus/Resolution</h4>
<ul>
<li>Deferred</li>
</ul>
<h2>4.10 Time zones 2: Time zone as property</h2>
<p>(Norbert Lindenberg)</p>
<p><a href="https://mail.mozilla.org/pipermail/es-discuss/2013-July/032080.html">https://mail.mozilla.org/pipermail/es-discuss/2013-July/032080.html</a></p>
<p>NL: Dean Landolt proposed a property on Date.prototype for the timezone, that all the functions look for, born with the default timezone, but can be changed.</p>
<p>MM: Should be static, like Date.now()</p>
<p>RW: Otherwise there would be Date objects with different timezones.</p>
<h4>Consensus/Resolution</h4>
<ul>
<li>Deferred</li>
</ul>
<h2>Date/Timezone</h2>
<p>Proposal 1
AVK: Having Date objects that have timezone as internal data instead of system data.</p>
<p>Proposal 2
NL: Pass time zone information separate from Date (as a parameter to methods)</p>
<h4>Consensus/Resolution</h4>
<ul>
<li>Write a strawman for ES7 (either)</li>
</ul>